defaults - ListLayoutServiceImplTest - 12 passed 5 failed
    add settings to application.properties for frequent and non categorized
    done - Finish category on add
    done - Finish category on delete
    done - Move up
    done - Move down
    Change layout
    Dish highlight flag
    Add dish
    Remove dish
    done - Listener to assign tag when moved from default tag

do we really need to save the category ids in the item??
    right now dictionary used in classification  before display and also in save
    I think we can remove the save - items saved without categories, and categorized each time for display.
    No - we need the save for the free text items - do the classification from the stored category ids
FREE TEXT!!!


    then - to front end


    default / switch for add lists upon generate
bugs -
    dishes with every tag added twice - I suspect tag assign tool

db cols to check -
tag.is_parent_tag
tag.rating_family

bigger todo list
    done set in process list active
        "page" for active list (only cross out, not delete)
        back end "set active" generateStrategy=replace|add

    list - cross out function

    dish retrieves tags only when single dish

    done statistics for what's crossed out often

    done - non-grocery items

    done list layouts

    bulk organizing tools -
        slots to tag structure (dnd)
        slots to layouts
        mass dishes to slots

    done - implement last added to list for dishes

    target

    recipe

    smoothing front end


little things
    add created on to dish entity

consider -
    filling objects in target and proposal in front end
        pass tagdictionary once - either in same request or not.
        use tagdictionary to fill objects in front end


autotag -

    some sort of cache/refresh for instructions

select distinct dt.dish_id , d.last_added , iT0.tag_id , iT1.tag_id
from dish_tags dt join dish d on d.dish_id = dt.dish_id and d.user_id = 1 and dt.tag_id = 5
left outer join dish_tags iT0 on d.dish_id = iT0.dish_id and iT0.tag_id = 169
left outer join dish_tags iT1 on d.dish_id = iT1.dish_id and iT1.tag_id = 212  order by d.last_added NULLS FIRST


sketch for menu finding algorithm

TagTypes

ingredientn
starascending
stardescending
type
mealplantype

create list of all slots - slots (and proposal)
do count of dishes per tag
tally tag count per slot
start with slot with lowest count

outer join for each tag in slot - count and total
  order by total, desc.



rest calls for lists

user creates a base list / pick up list
    POST list?type=BaseList|PickUpList

user adds / deletes slots to a base list / pick up list
    POST list/id/tag/tag_id
    DELETE list/id/tag/tag_id

user generates an active list
    POST list?generateType=replace|add&type=Active

user crosses off items from an active list
    PUT list/id/tag/tag_id


general note

    clean up - not much checking for null userids, null values in calls, etc.
        needs a pass through with tests trying to break.


